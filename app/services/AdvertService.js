const db = require("../database/db");
const Advert = db.Advert;
const Sequelize = require("sequelize");
const Op = Sequelize.Op;

class AdvertService {

    /**
     * Advert published by user with id = userId
     * @param userId - user id
     * @returns {Promise<Advert[]>} - promise with result as list of adverts
     */
    getAdvertsByUser(userId) {
        return Advert.findAll({where: {userId},
            include: [db.User]});
    }

    /**
     * Find adverts which not present in likes and dislikes table with `userId`
     *                !!! Result don't include user object !!!
     * @param userId - user id
     * @param limit - max count of adverts
     * @returns {Promise<Advert[]>} - promise with result as array of found adverts
     */
    async advertsNotPresentInLikeDislikeByUser(userId, limit = 20) {
        let user = await db.User.findByPk(userId);
        let result = [[]]; // stub for empty
        if (user) {
            result = await db.executeRawQuery(`call searchNotWatched($userId, $limit)`, {
                bind: {userId, limit},
                model: Advert,
                mapToModel: true
            });
        }
        return result[0];
    }

    /**
     * List of users whose liked advert with 'advertId'
     * @param advertId - advert id
     * @param advertOwnerId - advert owner
     */
    async likedUsers(advertId, advertOwnerId) {
        const transaction = await Advert.sequelize.transaction();
        try {
            const advert = await Advert.findByPk(advertId);
            if (advert && advert.userId === advertOwnerId) {
                const users = await advert.getLikeUsers({where: Sequelize.literal("like.watched = 0")}); // generated by sequelize
                if (users.length > 0) {
                    await db.Like.update({watched: 1}, {
                        where: {
                            [Op.and]: [{advertId}, {watched: 0}]
                        }
                    });
                }
                transaction.commit();
                return users;
            }
        } catch (e) {
            transaction.rollback();
        }
        return null;
    }

    /**
     * Create advert and save to database
     * @param advert - advert object
     * @returns {Promise<Advert>} - promise with result as crated advert
     */
    create(advert) {
        return Advert.create(advert);
    }

    /**
     * Get adverts by id, if id is undefined return all adverts
     * @param id
     * @param limit - limit of returned adverts
     * @returns {Promise<Advert | null>|Promise<Advert[]>}
     */
    get(id, limit = 20) {
        if (id) {
            return Advert.findByPk(id);
        } else {
            limit = limit > 20 ? 20 : limit;
            return Advert.findAll({limit});
        }
    }

    /**
     * Update advert by id
     * @param id
     * @param advert
     * @returns {Promise<Advert|null|Advert[]>}
     */
    async update(id, advert) {
        const [updated] = await Advert.update(advert, {where: {id}});
        if (updated) {
            return this.get(id);
        }
    }

    /**
     * Delete advert by id
     * @param id
     * @returns {Promise<boolean>} - true if deleted, otherwise false
     */
    async delete(id) {
        const deleted = await Advert.destroy({where: {id}});
        return !!deleted;
    }
}

module.exports = AdvertService;